\begin{proof}[\hyperanchor{pf:ahbtr-security-equivalence}{Theorem~\ref{thm:ahbtr-security-equivalence}}]
The reductionist proof of necessity is straight-forward by setting ${Q=0}$ (resp.~${Q=1}$) for completeness (resp.~soundness).

To show sufficiency, suppose the AH-BTR scheme $(\Gen,\Enc,\Dec,\Trace)$ is both complete and sound and let $\scriptB$ be an efficient adversary against its traceability.
We consider two efficient adversaries.
$\scriptC_1$ is against the completeness of the scheme.
It works by internally simulating the traceability game for~$\scriptB$ and outputting (in the completeness experiment) whatever $\scriptB$ outputs.
Denoting probabilities and events for adversary~$\scriptX$ in its security experiment with subscript~$\scriptX$,
\begin{align*}
\GoodDist_{\scriptC_1}
\Longleftrightarrow
\GoodDist_\scriptB
\qquad\textup{and}\qquad
\NotFound_{\scriptC_1}
\Longleftrightarrow
\NotFound_\scriptB.
\end{align*}
Therefore,
\begin{align*}
\Pr_\scriptB[\GoodDist_\scriptB\wedge\NotFound_\scriptB]
=
\Pr_{\scriptC_1}
[\GoodDist_{\scriptC_1}\wedge\NotFound_{\scriptC_1}].
\end{align*}
$\scriptC_2$ is against the soundness of the scheme.
Let ${B=\poly(\lambda)>1}$ be an upper bound of~$Q$ that $\scriptB$ might ever output.
$\scriptC_2$ does the following:
\begin{itemize}
\item $\scriptC_2(\pk)$ launches~$\scriptB$, receives $1^Q$ from it,
samples and sets
\begin{align*}
s^\ast&{}\draws[B],&
\pk_{s^\ast}&{}\gets\pk,\\
S&{}\gets[Q],&
(\pk_q,\sk_q)&{}\draws\Gen()\quad\textup{for }q\in{[Q]\setminus{\{s^\ast\}}},
\end{align*}
and sends $\{\pk_q\}_{q\in[Q]}$ to~$\scriptB$.
\item $\scriptC_2$ answers queries from $\scriptB$ and updates $S$ as stipulated by the query phase of the traceability experiment, except that it aborts if $\scriptB$ queries for~$\sk_{s^\ast}$.
\item After the query phase, $\scriptB$ outputs
\begin{align*}
\scriptD,\quad
\{\pk_j^\ast\}_{j\in[N]},\quad
1^{1/\epsilon^\ast},
\end{align*}
and $\scriptC_2$ samples or sets
\begin{align*}
i_\bot^\ast\begin{cases}
\draws I_\bot^\ast,&\textup{if }
I_\bot^\ast\gets
\{\,
{i\in[N]}
\::\:
{\pk_i^\ast=\pk}
\,\}\neq\varnothing;\\
\gets\bot&\textup{otherwise}.
\end{cases}
\end{align*}
It aborts if ${i_\bot^\ast=\bot}$.
Otherwise, $\scriptC_2$ outputs
\begin{align*}
\scriptD,\quad
N,\quad
i_\bot^\ast,\quad
\{\pk_j^\ast\}_{j\in{[N]\setminus{\{i_\bot^\ast\}}}},\quad
1^{1/\epsilon^\ast}.
\end{align*}
\end{itemize}
% This is a coupling argument.
Routine calculation yields
\begin{align*}
\Pr_{\scriptC_2}[\FalsePos_{\scriptC_2}]
\geq\frac{1}{B^2}\Pr_\scriptB[\FalsePos_\scriptB].
\end{align*}
By the union bound,
\begin{align*}
&
\Pr_\scriptB[\FalsePos_\scriptB\vee(\GoodDist_\scriptB\wedge\NotFound_\scriptB)]
\\{}\leq{}&
\Pr_\scriptB[\FalsePos_\scriptB]
+
\Pr_\scriptB[\GoodDist_\scriptB\wedge\NotFound_\scriptB]
\\{}\leq{}&
B^2\Pr_{\scriptC_2}[\FalsePos_{\scriptC_2}]
+
\Pr_{\scriptC_1}[\GoodDist_{\scriptC_1}\wedge\NotFound_{\scriptC_1}]
\WideNarrow{}{\hspace*{-1em}}
\\{}={}&
(\poly(\lambda))^2\negl(\lambda)+\negl(\lambda)
=
\negl(\lambda).
\qedhere
\end{align*}
\end{proof}

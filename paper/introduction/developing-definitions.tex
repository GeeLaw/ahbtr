\subsubsection{Developing Definitions.}
We start with the first principles of \ad hoc traitor tracing.
Syntactically, there should be a key generation algorithm that is run by each user of the system.
To encrypt, a list of public keys is used to identify the set of recipients.
Decryption should only require one secret key from the list of public keys.
In addition, the decryptor gets random access to all the recipients' public keys as well as the ciphertext.
The choice to give random access to these inputs is based on performance concerns, as the decryptor might not have to read all of the public keys or the ciphertext.

Before going into tracing, it should be clear that such a scheme would automatically have the functionality of \ad hoc broadcast encryption.
There is no event prior to encryption that ``binds'' the system to a specific, fixed set of possible recipients, and the encryptor is free to use whatever public keys it sees fit.
Similarly, the encryptor is free to remove any public key when it encrypts a second ciphertext, i.e., the scheme automatically enjoys the capability of revocation.
Therefore, the object is named \ad hoc broadcast, trace, and revoke (AH-BTR).

As usual with broadcast encryption, we do not hide the list of recipients.
Hiding the recipients makes ciphertext grow at least linearly with the number of recipients, deminishing the potential of succinctness.
As we shall see, it is possible to construct AH-BTR with short ciphertexts.

Due to the decentralized nature of such systems,
an adversary could indistinguishably generate malformed keys,
which could potentially evade tracers that only take well-formed keys into account.
To make it worse, a malformed key could mount a denial-of-service attack against (other) honest users if it appears in the list of recipients' public keys during encryption ---
the encryption algorithm might have been carelessly designed and the presence of certain malformed keys could make it impossible to decrypt for anyone, including the recipients with honsetly generated public keys.

In order to protect against such attacks by definition,
we define correctness to be \emph{robust} against malformed keys ---
however, for performance reasons, namely to be able to index into any particular public key in constant time,
we reject \emph{blatantly} malformed keys, e.g., those of incorrect lengths.
When attacking the \emph{traceability} of the scheme, the adversary is free to supply any public key, generated honestly by the challenger or (adversarially) by the adversary, so that the definition covers the scenario when a malformed key is present in the list of recipients' public keys.
The tracing algorithm must \emph{not accuse} an honest user, defined as one whose public key is generated by the challenger without its secret key revealed to the adversary.
It \emph{must find} a traitor as long as the decoder has sufficient advantage (i.e., succeeds in decrypting with sufficient probability), where \emph{traitors} are associated with public keys either generated by the challenger with their secret keys revealed to the adversary or crafted by the adversary in any manner (e.g., skewed distribution, or even without a well-defined secret key).
Again, blatantly malformed keys are rejected.

Once the issues above are identified and conceptually resolved (as done here),
it is straight-forward to define AH-BTR analogously to traditional traitor tracing schemes.

\subsubsection{You Can (Not) Optimize.}
While our basic construction enjoys constant-size ciphertext,
its decryption algorithm runs in time~$\bigOmega(N)$.
Concretely, the LOT hash is a Merkle tree, and before performing LOT decryption, it is necessary to reconstruct the tree as it is not stored in the ciphertext.
In contrast, the decryption time of the scheme implied by the na{\"i}ve PLBE is constant in the RAM model, as it only looks at the relevant piece of the underlying PKE ciphertext.

We can trade ciphertext size for decryption time by using the na{\"i}ve PLBE on top of our construction.
By grouping the recipients into $\Theta(N^{1-\gamma})$ sets of size~$\Theta(N^\gamma)$ and using our basic construction over each set, we obtain a scheme with ciphertext size~$\Theta(N^{1-\gamma})$ and decryption time~$\Theta(N^\gamma)$.
This transformation was formalized as the user expansion compiler~\cite{C:Zhandry20} in the context of traditional traitor tracing.

All the constructions we now know have ${|\ct|\cdot\TDec=\bigOmega(N)}$,
where $|\ct|$ is the ciphertext length and $\TDec$ is the decryption time.
It turns out that this bound necessarily holds for all secure AH-BTR, and
the blame is on the functionality of broadcast encryption (not traitor tracing).
% I haven't verified whether TT from LWE has short decryption time,
% so no citation at this moment.
Indeed, 
it is possible to make both $|\ct|$ and $\TDec$ constant in a traditional traitor tracing scheme~\cite{C:BonZha14}.
In existing broadcast encryption (or revocation) schemes~\cite{C:BonGenWat05,AC:Delerablee07,EC:GenWat09,C:BonZha14,EC:AgrYam20,TCC:AgrWicYam20,EPRINT:BraVai20} for $N$ users,
encrypting to arbitrary subsets of size~$S$ or $({N-S})$ makes ${|\ct|\cdot\TDec=\Omega(S)}$.
It is precisely the capability to encrypt to many $\Theta(N)$-subsets among $N$ users that is the deal breaker, as we shall see in the formal proof.
Interestingly,
the adversary used in the proof is simply the decryption algorithm,
so the bound holds as long as the scheme is not \emph{blatantly} insecure.

We explain the ideas of our proof based on a corollary of a result~\cite{C:Unruh07} dealing with random oracles in the presence of non-uniform advice.
Let ${S,T\geq 0}$ be such that ${ST\ll N}$.
The corollary says that
for any adversary learning any $S$-bit function (advice) of a random string~${R\draws\bit^N}$ and additionally (adaptively) querying at most $T$ bits in~$R$,
it is ``indistinguishable'' to flip a bit in~$R$ at a random location
after the advice is computed (using the non-flipped~$R$) and
before queries are answered,
even if the index of the potentially flipped bit is known to the adversary.

Back to AH-BTR. Imagine that there are $2N$ users in the system, associated with key pairs $(\pk_{j,b},\sk_{j,b})$ for ${j\in[N]}$ and ${b\in\bit}$.
Consider a ciphertext~$\ct$ encrypting a random plaintext to $\{\pk_{j,R[j]}\}_{j\in[N]}$ for a random string~$R$ and
regard $\ct$ as the advice.
Let's try decrypting~$\ct$ using $\sk_{j,R[j]}$ for a random ${j\draws[N]}$.
Each time the AH-BTR decryption algorithm queries~$\pk_j$,
we probe $R[j]$ and respond with~$\pk_{j,R[j]}$.
By way of contradiction, suppose ${|\ct|\cdot\TDec\ll N}$,
which would translate to the setting of the corollary as ${S=|\ct|}$, ${T\leq\TDec}$, and ${ST\ll N}$.

By the correctness of AH-BTR,
the attempted decryption should successfully recover the plaintext.
From the corollary it follows that flipping $R[j]$ should also lead to successful recovery.
But if $R[j]$ is flipped after $\ct$ is computed,
by the security of AH-BTR,
the attempted decryption should fail to recover the plaintext except for negligible probability, yielding a contradiction.
